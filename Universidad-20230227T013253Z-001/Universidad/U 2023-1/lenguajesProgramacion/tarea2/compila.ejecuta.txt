#lang plai

;; BNF
;;<F1WAE> ::-<number>
;;        | {+ <F1WAE> <F1WAE>}
;;        | {- <F1WAE> <F1WAE>}      
;;        | {with {<id> <F1WAE>} <F1WAE>}
;;        |  <id>
;;        | {<id> <F1WAE>}
  

;; AST para F1WAE: First-Orden Functions With Aritmetic Expression
(define-type F1WAE 
  [num (n number?)] 
  [add (l F1WAE?) (r F1WAE?)] 
  [sub (l F1WAE?) (r F1WAE?)] 
  [with (name symbol?) (value F1WAE?) (body F1WAE?)] 
  [id (name symbol?)]
  ;;extension para soportar la aplicacion de funciones
  [app (fun-name symbol?) (arg F1WAE?)] 
  [struct_ (name string?) (fields (list (list string? number?)))])

;; AST para una funcion
(define-type FunDef
  [fundef (fun-name symbol?) (arg-name symbol?) (body F1WAE?)])

;; AST para una estructura
(define-type StructDef
  [structdef (struct-name symbol?) (arg-name symbol?) (body F1WAE?)])


;; parse: Program -> AST (F1WAE)
(define (parse program)
  (cond
    [(number? program) (num program)]
    [(symbol? program) (id program)]
    [(list? program)
     (case (first program)
       [(+) (add (parse(second program))
                 (parse(third program)))]
       [(-) (sub (parse(second program))
                 (parse(third program)))]
     
       [(with) (with (first (second program))
                     (parse (second (second program)))
                     (parse (third program)))]
       [(-s) (struct_ (second program) (third program))] ; {"scarlet" (("edad" 25) ("salary" 200000))}
       [else (app (first program) (parse (second program)))])]))  ; {foo 3}, {foo {+ 4 5}},{foo {with {x 5} {+ 3 x}}}, {foo {bar 3}}


;; parser os functions
(define (parse-function function)
  [fundef (first function) (second function) (parse (third function))])


;; parser of list of functions (Usa la funcion de arriba) 
(define (parse-functionS listf)
  (cond
    ((empty? listf) '())
    (else (cons (parse-function (first listf)) (parse-functionS (rest listf))))))




;; lookup-fundef : symbol (id) x Lista de FunDefs -> FunDef
(define (lookup-fundef fun-name fundefs)
  (cond
    [(empty? fundefs) (error fun-name "function not found")]
    [else (if (symbol=? fun-name (fundef-fun-name (first fundefs)))
            (first fundefs)
            (lookup-fundef fun-name (rest fundefs)))]))
;;--------------------------------------------------
(define (lookup-structdef fun-name fundefs)
  (cond
    [(empty? fundefs) (error fun-name "struct not found")]
    [else (if (symbol=? fun-name (fundef-fun-name (first fundefs)))
            (first fundefs)
            (lookup-fundef fun-name (rest fundefs)))]))



;; subst : F1WAE x symbol x AST → AST (sin identificadores)
(define (subst expr sub-id val) 
  (type-case F1WAE expr 
             [num (n) expr] 
             [add (l r) (add (subst l sub-id val) 
                             (subst r sub-id val))] 
             [sub (l r) (sub (subst l sub-id val) 
                             (subst r sub-id val))] 
             [with (bound-id named-expr bound-body) 
                   (if (symbol=? bound-id sub-id) 
                       (with bound-id 
                             (subst named-expr sub-id val) 
                             bound-body) 
                       (with bound-id 
                             (subst named-expr sub-id val) 
                             (subst bound-body sub-id val)))] 
             [id (v) (if (symbol=? v sub-id) val expr)]
             ;;extension: posible substituciones dentro la funciones
             [app (fun-name arg-expr) (app fun-name (subst arg-expr sub-id val))]
             [struct_ (struct-name arg-expr) (struct_ struct-name (subst arg-expr sub-id val))]


    
             )) 


;; Interprete
;; interp : AST x Lista de fundef -> number 
(define (interp expr fun-defs)
  (type-case F1WAE expr
             [num (n) n]
             [add (l r) (+ (interp l fun-defs) (interp r fun-defs))]
             [sub (l r) (- (interp l fun-defs) (interp r fun-defs))]
             [with (bound-id named-expr bound-body)
                   (interp (subst bound-body
                                  bound-id
                                  (num (interp named-expr fun-defs)))
                           fun-defs)]
             [id (v) (error 'interp "free identifier")]
             [app (fun-name arg-expr)
                  (begin
                    (printf "name ~s" fun-name)
                  (let ([the-fun-def (lookup-fundef fun-name fun-defs)])
                    (interp (subst (fundef-body the-fun-def )
                                   (fundef-arg-name the-fun-def )
                                  (num (interp arg-expr fun-defs)))
                            fun-defs)))]
              [struct_ (struct-name arg-expr)
                  (begin
                    (printf "name ~s" struct-name)
                  (let ([the-struct-def (lookup-structdef struct-name fun-defs)])
                    (interp (subst (structdef-body the-struct-def )
                                   (structdef-arg-name the-struct-def )
                                  (num (interp arg-expr fun-defs)))
                            fun-defs)))]
    

             
    ))


;; Una función para simplificar el uso, pero usando funciones
;; ejecutar: Program x Lista de funDef -> number
(define (ejecutar program [list-funs '()]) 
  (interp (parse program) list-funs))

(define (ejecutar-parse-functions program [list-funs '()])
  (interp (parse program) (parse-functionS list-funs)))


; TEST PARSER
(printf "~nTEST PARA PARSER~n")
(test (parse '3) (num 3))
(test (parse '{+ 1 2}) (add (num 1) (num 2)))
(test (parse '{+ {- 2 1} 3}) (add (sub (num 2) (num 1)) (num 3)))
;;(test (parse '{-s "hola" '()}) (struct_ (num "hola") (list '())))
;; withs
(test (parse '{with {x 1} 1}) (with 'x (num 1) (num 1)))
(test (parse '{with {x 2} x}) (with 'x (num 2) (id 'x)))
(test (parse '{with {x 1} {+ x 1}}) (with 'x (num 1) (add (id 'x) (num 1))))
(test (parse '{with {x {+ 3 1}} x}) (with 'x (add (num 3) (num 1)) (id 'x)))
(test (parse '{+ {with {x 4} x} 3}) (add (with 'x (num 4) (id 'x)) (num 3)))

(printf "~nTEST PARA INTERPRETES~n")
; TEST INTERPRETE
(test (ejecutar '3) 3)
(test (ejecutar '{+ 1 2}) 3)
(test (ejecutar '{+ {- 2 1} 3}) 4)

;;withs
(test (ejecutar '{with {x 1} 1}) 1)
(test (ejecutar '{with {x 2} x}) 2)
(test (ejecutar '{with {x 2} {+ x 1}}) 3)
(test (ejecutar '{with {x 5} {+ x {with {x 3} 10}}}) 15)
(test (ejecutar '{with {x 5} {+ x {with {x 3} x}}}) 8)
(test (ejecutar '{with {x 5} {+ x {with {y 3} x}}}) 10)
(test (ejecutar '{with {x 5} {with {y x} y}}) 5)
(test/exn (ejecutar '{with {x x} x}) "free identifier")

;; funs-sin-parsear
(test (ejecutar '{double 5} (list (fundef 'double 'n (add (id 'n) (id 'n))))) 10)
(test (ejecutar '{add1 {double 5}} (list (fundef 'double 'n (add (id 'n) (id 'n))) (fundef 'add1 'num (add (num 1) (id 'num))))) 11)
(test/exn (ejecutar '{triple 5} (list (fundef 'double 'n (add (id 'n) (id 'n))))) "function not found")

;; funs-parseada
(test (ejecutar-parse-functions '{double 5} (list '{double n {+ n n}})) 10)
(test (ejecutar-parse-functions '{add1 {double 5}} (list '{double n {+ n n}} '{add1 x {+ x 1}})) 11)
(test (ejecutar-parse-functions '{+ {double 5} 10} (list '{double n {+ n n}})) 20)
(test/exn (ejecutar-parse-functions '{triple 5} (list '{double n {+ n n}})) "function not found")
(test (ejecutar-parse-functions '{triple 5} (list '{double n {+ n n}} '{triple x {+ x {double x}}})) (+ 10 5))
;;struct_
(test (ejecutar '{+ 1 2}) 3)

